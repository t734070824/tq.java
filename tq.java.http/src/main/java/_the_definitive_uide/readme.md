2017-12-01
## 1.URL
1.URL 提供了一种统一的资源命名方式。 大多数 URL 都有同样的：“**方案 :// 服务器位置 / 路径**” 结构
2.通用格式`<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`

## 提高HTTP的连接性能
### 并行连接
- 浏览同时发起过个http事务，因为是并行的，所以时延也并行的，这样总时延较小，页面呈现更快，体验较好。但也不是总是这样，因为如果在网络速度很慢的时候，多个连接会去竞争本来不多的带宽，那么就谈不上加快速度了。还有就是并行连接也是需要付出代价的，比如增加系统内训消耗、服务器负载，比如有一个100客户端同时对服务发起100tcp并行连接的话，那么服务器就得负责10000个处理请求，很快的你的服务器就会爆掉。当然了，并行连接确实能带来视觉上的速度提升，因为相比于串行连接慢慢地显示数据而并行一下子能全部显示完信息，视觉上并行连接会给人速度更快的感觉！

### 持久连接
- 持久连接描述的是：如果对同ip、同端口的发起多个http事务连接，那么可以在前一个事务处理完成之后不要关闭tcp连接，以此来减小建立tcp、tcp慢启动所带来的时延。相关概念不在赘述！

### 管道化连接
- HTTP/1.1允许在持久连接上可选地使用请求管道。这是在keep-alive连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。

### 管道连接的限制
- 如果不是持久连接就不要使用管道连接
接收端必须按收到请求报文的顺序返回响应报文，因为HTTP报文中没有序列号标签。所以必须靠按序发送响应报文来达到“数据对应”
发送端应该做好数据没有发送完连接就关闭的准备并开始重新发送数据。
HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。
### 复用的连接
- 交替传送请求和响应报文（实验阶段）。

## 代理和网关的对比
- 代理的两端使用相同的协议，而网关的两端使用不同的协议，网关负责协议转换！
## Connection首部和盲中继
![](https://github.com/t734070824/tq.java/blob/master/tq.java.http/src/main/java/_the_definitive_uide/1.png?raw=true)

这幅图中发生的情况如下所示。
- 在图 4-15a 中， Web 客户端向代理发送了一条报文， 其中包含了 Connection:Keep-Alive 首部， 如果可能的话请求建立一条 keep-alive 连接。 客户端等待响应， 以确定对方是否认可它对 keep-alive 信道的请求。
- 哑代理收到了这条 HTTP 请求， 但它并不理解 Connection 首部（只是将其作为一个扩展首部对待）。 代理不知道 keep-alive 是什么意思， 因此只是沿着转发链路将报文一字不漏地发送给服务器（图 4-15b）。 但 Connection 首部是个逐跳首部， 只适用于单条传输链路， 不应该沿着传输链路向下传输。 接下来， 就要发生一些很糟糕的事情了。
- 在图 4-15b 中， 经过中继的 HTTP 请求抵达了 Web 服务器。 当 Web 服务器收到经过代理转发的 Connection: Keep-Alive 首部时， 会误以为代理（对服务器来说， 这个代理看起来就和所有其他客户端一样） 希望进行 keep-alive 对话！ 对Web 服务器来说这没什么问题——它同意进行 keep-alive 对话， 并在图 4-15c 中回送了一个 Connection: Keep-Alive 响应首部。 所以， 此时 Web 服务器认为它在与代理进行 keep-alive 对话， 会遵循 keep-alive 的规则。 但代理却对 keepalive 一无所知。 不妙。
- 在图 4-15d 中， 哑代理将 Web 服务器的响应报文回送给客户端， 并将来自 Web服务器的 Connection: Keep-Alive 首部一起传送过去。 客户端看到这个首部， 就会认为代理同意进行 keep-alive 对话。 所以， 此时客户端和服务器都认为它们在进行 keep-alive 对话， 但与它们进行对话的代理却对 keep-alive 一无所知。
- 由于代理对 keep-alive 一无所知， 所以会将收到的所有数据都回送给客户端， 然后等待源端服务器关闭连接。 但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了， 所以不会去关闭连接。 这样， 代理就会挂在那里等待连接的关闭。
- 客户端在图 4-15d 中收到了回送的响应报文时， 会立即转向下一条请求， 在 keepalive 连接上向代理发送另一条请求（参见图 4-15e）。 而代理并不认为同一条连接上会有其他请求到来， 请求被忽略， 浏览器就在这里转圈， 不会有任何进展了。
|- 这种错误的通信方式会使浏览器一直处于挂起状态， 直到客户端或服务器将连接超时， 并将其关闭为止。

### 代理和逐跳首部
- 为避免此类代理通信问题的发生， 现代的代理都绝不能转发 Connection 首部和所有名字出现在 Connection 值中的首部。 因此， 如果一个代理收到了一个Connection: Keep-Alive 首部， 是不应该转发 Connection 首部， 或所有名为Keep-Alive 的首部的。另外， 还有几个不能作为 Connection 首部值列出， 也不能被代理转发或作为缓存响应使用的首部。 其中包括 Proxy-Authenticate、 Proxy-Connection、Transfer-Encoding 和 Upgrade


