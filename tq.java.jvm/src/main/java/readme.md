2017-11-28

### JVM中，堆和栈都位于内存中，而数据在栈上分配相比在堆上分配至少有以下两点差别：
1. 栈上存储的数据，很大机会会被虚拟机分配至物理机器的高速寄存器中存储。因而读写效率比从堆内存中读写高很多。
2. 栈上分配的数据，释放时只需要通过移动栈顶指针，就可以随着栈帧出栈而自动销毁。而堆内存的释放由垃圾回收器负责完成，
		这一过程中整理和回收内存都需要消耗更多的时间。
		
### happens—before		 
1. 程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作。
2. 管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序，下同）对同一个锁的lock操作。
3. volatile变量规则：对一个volatile变量的写操作happen—before后面对该变量的读操作。
4. 线程启动规则：Thread对象的start（）方法happen—before此线程的每一个动作。
5. 线程终止规则：线程的所有操作都happen—before对此线程的终止检测，
     可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
6. 线程中断规则：对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。
7. 对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。
8. 传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。

### Java 中堆和栈有什么区别
1. JVM 中堆和栈属于不同的内存区域，使用目的也不同
2. 栈常用于保存方法帧和局部变量, 而对象总是在堆上分配
3. 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

### 堆区大小动态变化
1. 参数-Xms和-Xmx来控制，-Xms为JVM启动时申请的最新heap内存，默认为物理内存的1/64但小于1GB;-Xmx为JVM可申请的最大Heap内存，默认为物理内存的1/4但小于1GB
2. 默认当剩余堆空间**小于40%时**，JVM会**增大Heap到-Xmx大小**，可通过-XX:MinHeapFreeRadio参数来控制这个比例
3. 当空余堆内存**大于70%时**，JVM会**减小Heap大小到-Xms指定大小**，可通过-XX:MaxHeapFreeRatio来指定这个比例
4. **将-Xms和-Xmx设置成一样来 避免在运行期间频繁的调整Heap大小**
5. 这就是 在 jstat 命令中 s0c s1c 等容量在不断变化的原因吧???

### JVM参数设置
1. 可以用 G 为单位, 但是 不可以用小数: -Xmx2.5 就不行