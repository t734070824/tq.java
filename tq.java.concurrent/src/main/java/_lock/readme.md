2018-04-18

## LOCK
https://coderbee.net/index.php/concurrent/20131115/577
1. 这里实现的锁都是独占的，且不能重入的

### 自旋锁（SPIN LOCK）
1. 指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态
2. **自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。**
3. 根本: CPU空转
3. 应用
    - **原子类: 自旋 + CAS**
3. 缺点:
    - CAS操作需要硬件的配合
    - 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；
    - 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁
    

### TICKET LOCK
1. 解决上面的公平性问题，类似于现实中银行柜台的排队叫号
2. 锁拥有一个服务号，表示正在服务的线程，还有一个排队号
3. 每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询    
4. 当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋
5. 缺点:
    - 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum
    - 每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能

### MCS Spinlock
1. 是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，
2. **直接前驱负责通知其结束自旋**，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销
3. 理解(MCSLockApp):
    - A 第一个获取锁, 因为没有其他线程, **直接获取锁, 设置自己node的 isBlock = false**;
    - B 第二个获取锁, 因为 A 持有锁, **设置 A.next = B, B 在 B.isBlock字段, 直到 A通知**
    - A 释放锁, **发现 A.next != null, 则: A.next.isBlock = false**, A.next = null, 此时 B 结束自旋, 获取锁

### CIH LOCK
1. CLH lock is Craig, Landin, and Hagersten (CLH) locks, CLH lock is a spin lock, can ensure no hunger, provide fairness first come first service. 
2. CLH是人名简写。这种锁本质是自旋锁，确保无饥饿、公平地先进先出竞争锁
3. 申请线程只在本地变量上自旋，**它不断轮询前驱的状态**，如果发现前驱释放了锁就结束自旋