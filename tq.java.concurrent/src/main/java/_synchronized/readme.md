2017-11-21


### 新的理解 20181219
1. 底层语义原理
    - 基于进入和退出管程(Monitor)对象实现
        - monitorenter, monitorexit
    - 执行线程先持有对象 monitor, 其他线程无法再次持有, 已持有线程可以再次持有
2. java虚拟机对 synchronized 的优化
    - 锁升级
        - 无锁状态, 偏向锁, 轻量级锁, 重量级锁
        - 锁升级是单向的, 无法降级
    - 偏向锁
        - 如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，
        - 当这个线程再次参与竞争所时，无需再做任何同步操作，即获取锁的过程，
        - 这样就省去了大量有关锁申请的操作，从而也就提供程序的性能
        - 适用于 锁竞争不激烈的场景
    - 轻量级锁
        - 如果多个线程竞争同一个偏向锁, 大部分情况下升级成 **轻量级锁**
        - 对绝大部分的锁，在整个同步周期内都不存在竞争
        - 如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。
    - 自旋锁
        - 这是基于在大多数情况下，线程持有锁的时间都不会太长，
        - 如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，
        - 这个状态之间的转换需要相对比较长的时间，时间成本相对较高，
        - 因此自旋锁会假设在不久将来，当前的线程可以获得锁
    - 自适应自旋锁
        - 线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数
    - 非同步阻塞 乐观锁
        - 轻量级锁, 自旋锁
    - 重量级锁
        - **基于 自旋锁的循环机制, 需要限制一个循环次数, 当超过次数之后, 就会升级为 重量级锁**
        - 开销大
            - 等待获取锁的线程 阻塞
            - 需要唤醒 / 阻塞, 用户态 --> 内核态
        - 阻塞同步, 悲观锁
    - 锁消除
        - 通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁
3. 线程中断和 synchronized
    - public void Thread.interrupt()
        - 实例方法
        - 中断线程
        - 只是设置中断标识
        - **需要手动代码检测**
    - public boolean Thread.isInterrupted();
        - 实例方法
        - 判断线程是否被中断 
    - public static boolean Thread.interrupted();
        - 判断是否被**中断并清除**当前中断状态
        - 静态方法
4. 唤醒机制和synchronized
    - **调用这几个方法前必须拿到当前对象的监视器monitor对象**


### synchronized
1) 原子性
2) 内存可见性:当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。
同样，在对象释放锁之前，它会刷新其高速缓存，强制使已做的任何更改都出现在主内存中。
这样，会保证在同一个锁上同步的两个线程看到在 synchronized 块内修改的变量的相同值
3) volatile只保证可见性，不保证原子性!
    - 内存屏障
    - 保证立刻被其他线程看到, 但在被看到之前, 可以多个线程同时修改啊

### synchronized 的缺点
1. 无法中断一个正在等候获得锁的线程
2. 无法通过投票获得锁
3. 同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行，多数情况下，
这没问题（而且与异常处理交互得很好），但是，确实存在一些非块结构的锁定更合适的情况。

2017-12-22
### 锁粒度细化
1. 很多时候我们会将实例的方法加 synchronized 关键字来达到数据同步的效果,
但此时是需要获得这个对象的锁才可以操作被锁的方法,如果只想修改这个实例的某个字段的时候
锁住整个对象就有些浪费了,通过将对象中需要同步的变量每一个分配一个锁,到达锁粒度细化的目标

### 可见性 原子性
1. 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
2. 可见性: 指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
        
