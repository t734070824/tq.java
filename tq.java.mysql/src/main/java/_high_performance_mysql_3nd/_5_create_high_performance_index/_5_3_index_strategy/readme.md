2018-09-17

## 高性能的索引策略

### 高性能的索引策略
1. 独立的列
    - 不能是表达式的一部分
    - 不能是函数的参数
2. 前缀索引和索引选择性
    - 前缀索引
        - 要求
            - 较高的选择性
            - 不能太长
            - 应该足够长, 使得选择性接近索引整个列
        - 优点
            - 使索引 更小 更快 
        - 缺点
            - 无法 Group by 以及 Order by
            - 无法做覆盖扫描
    - 索引的选择性
        - **不重复的索引值** 和 数据表记录总数的比值
        - 较高的比值可以在查询的时候过滤更多的行
    - 其他想法
        - 后缀索引
            - mysql 不支持
            - 字符串反转后存储....

### 多列索引与索引顺序
1. 索引顺序
    - 选择性最高的放在索引的最前列
        - 但同时也需要根据具体的情况选择索引顺序
    - 虽然经验法则依然生效, 但最好是根据具体的数据类型来修改索引

### 聚簇索引
1. 什么是聚簇索引
    - 对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致
    - 一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引
    - 在 InnoDB 中, **聚簇索引 "就是" 表**
2. 优点
    - 把相关的数据保存在一起
    - 数据访问更快
    - 使用覆盖索引扫描的查询可以直接使用页节点中的主键值
3. 缺点
    - 最大限度的提高了IO密集型应用的性能, 但是如果数据全部都放在内存中, 优势就不能明显了
    - 插入速度依赖于 插入排序
    - 更新聚簇索引列的代价更高, 强制 InnoDB 将每一个被更新的列移动到新的位置
    - 在插入新行 或者是 主键被更新需要移动行的时候, 可能面临 "页分裂" 的问题, 
4. 二级索引
    - mysql中每个表都有一个聚簇索引（clustered index ），除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）
    - 以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。如果您的表上定义有主键，该主键索引是聚集索引。如果你不定义为您的
    表的主键时，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚集索引。如果没有这样的列，
    InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引
    - 二级索引叶子节点保存的不是指向行的物理地址, 而是行的主键值
    - 通过二级索引查找行, 需要存储引擎找到二级索引的叶子节点获取对应的主键值, 然后根据这个主键值去聚簇索引中查找对应的行
5. 建议
    - 避免随机的聚簇索引
        - 因为索引是有序的, 但是插入的值不一定是有序的
        - 因为写入的乱序, Innodb就要不停的扩充 页, 导致页的不连续, 造成页的大量修改(移动)
        - 频繁的页分裂, 稀疏, 碎片
    - 顺序的主键造成更坏的结果
        - 主键的上界 会成为 "热点", 争用, 导致间隙锁竞争
        - Auto-Increment 锁机制, 
            - 自增列争用
            - TODO

### 覆盖索引
1. 一个索引包含了所有需要查询的字段值

### 使用索引扫描来做排序
1. 最好用同一个索引 **既满足排序有可以用于查询**
2. order by
    - 当索引的列顺序和Order by子句的顺序完全一致, 并且所有的列的排序方向都一致
    - 关联多张表, 只有order by子句引用的字段全部为第一张表时, 才会使用索引做排序
3. 索引的前导列为常量
    - order by子句可以不满足索引的最左前缀的要求 
4. 多表联合查询的时候 索引的使用需要研究...

### 压缩(前缀压缩)索引
1. MyISAM

### 冗余和重复索引

### 索引和锁
1. Innodb只有在访问行的时候才会对其加锁, 而索引能够减少Innodb访问的行数, 从而减少锁的数量




