2018-09-10

## Schema与数据类型优化

### 选择优化的数据类型
1. 尽量使用可以正确存储数据的最小数据类型
    - 更小的数据类型通常占用更小的磁盘, 内存, CPU
2. 简单就好
    - 整数类型比字符串操作代价更低
    - 使用Mysql内建的类型(date, time, dateTime)而不是字符串表示日期
    - 使用整型存储IP
3. 尽量避免使用null
    - mysql难以优化
    - 避免在可能为null的列建立索引
4. 选择具体类型
    - TimeStamp VS DataTime
    
### 整数类型
1. 整数
    - TinyInt(8), SmallInt(16), MediumInt(24), Int(32), BigInt(64)
    - 存储范围 -2(N-1) 到 2(N-1)-1
    - Unsigned: 不允许负值
        - 存储内容大致上升一倍
    - 为整数类型指定宽度
        - Int(11), 不会限制值的合法范围
        - 对于存储和计算来说, Int(1) 和 Int(20) 是相同的
2. 实数
    - Float
    - Double
    - Decimal
    - 可以将小数乘以一个响应的倍数, 保存为整数存储
    
### 字符串类型(InnoDB/MyISAM)
1. VarChar  Char
    - VarChar
        - 可变长字符串(无法超过最大长度)
        - 仅适用必要的空间(越短的字符串使用越少的空间), 但是 ROW_Format=FIXED
        - **使用 1 或者 2 额外个字节记录字符串的长度**
            - 列的最长长度<=255byte --> 1
        - 缺点
            - 由于行的变长,在Update的时候可能是行变的更长, 但是页内没有更多的空间存储, **Innodb需要分裂页使行可以放进页内**
            - Innodb会把过长的Varchar存储为 Blob;???
        - 适用于
            - 字符串的最大长度比平均长度大得多
            - 列的更新较少
    - Char
        - 定长的
        - 根据需要填充空格以方便比较
        - 适用于
            - 很短的 或者是 所有值都接近同一个长度
            - 经常变更的, 不容易产生碎片
3. Binary VarBinary
    - 二进制字符串
    - 存储字节码而不是字符
    - 填充Binary使用 \0(零字节)
    - 比较Binary字符串, 因为每次按一个字节, 速度较快
4. Blob  VS  TEXT
    - Blod
        - 二进制
        - TinyBlob, SmallBlob, MediumBlob, IntBlob, BigBlob
    - TEXT
        - 字符
        - TinyText, SmallText, MediumText, IntText, BigText
    - 共同点
        - 存储很大数据而设计的字符串数据类型
        - 排序 只对每个列最前的 max_sort_lenght 字节而不是整个字符串排序
        - 不能将这种列全部长度的字符串进行索引, 也不能使用这些索引消除排序???
5. 枚举 Enum
    - 可以带起字符串类型
    - **数据实际存储的是整数**
    - 无法轻易改变, 修改 Alter Table 来修改
    
### 日期和时间类型
1. datetime
    - 大范围的值 1001年-9999年, 精度为秒, 
    - 日期与时间封装为 YYYYMMDDHHMMSS的整数, 与时区无关
    - 8个字节
2. timestamp
    - 1970-01-01到现在的秒数, 
    - 4个字节 1970-2038
    
### 位数据类型
1. bit
    - bit(N) 定义一个存储N位的字段
    - mysql把bit当做字符串处理, 而不是数字类型
    - 但是, b'00111001'+0=57, 有时候根据上下文会将其作为数字处理
    - 谨慎使用
2. Set
    - 保存很多true/false
    - 在整数列上进行按位操作
        - 使用一个整数包装一系列的位
        - 把8个位包装到一个Tinyint中,并且按位操作来使用

### 选择标识符(identifier)
1. 选择合适的数据类型很重要
2. 最好在相关联的表中使用相同的数据类型
3. 最好使用整数类型
4. 注意完全随机的字符串
    - 这些新值后任意分布在很大的空间内, 导致Insert, Select变得很慢
        - 插入值会随机的写到索引的不同位置, 是的insert变慢, 导致页分裂, 磁盘随机访问 以及聚簇索引引擎产生聚簇索引碎片???
        - select会变慢, 因为逻辑上相邻的行会分布在磁盘和内存的不同地方
        - 导致缓存赖以工作的访问局部性原理失效???
        
### 特殊数据类型
1. ip--无符号整数

### Mysql Schema 设计中的陷阱
1. 太多的列???
2. 太多的关联
     - 最多: **61**
     - 最优: **12**
3. 全能的枚举
4. Null


## 范式与反范式

### 范式的缺点与优点
1. 优点
    - 更新操作更快
    - 很少有重复数据, 修改更少
    - 表小, 执行操作更快
    - 更少的Distinct 或者 Group by语句
2. 缺点
    - 通常需要关联

### 混用范式化与反范式化
1. 复制与缓存

### 缓存表与汇总表
1. 有时提升性能最好的方法 在同一张表中保存衍生的冗余数据
2. 完全独立的汇总表或者缓存表
    - 汇总表
        - 不严格计数
        - 小范围查询**填满间隙**的 严格计数
    - 缓存表

### 计数器表
1. 应用场景
    - 缓存一个用户的朋友数, 文件下载次数, 网页的点击次数
2. 设计
    - 一个计数器表, 一个字段, 更新的时候每次加一
3. 问题
    - 对于任何要更新这一行的事务来说, 这个记录有一个**全局的互斥锁**
    - 造成事务串行执行
4. 优化
    - 增加一列, 一个随机的槽位
    - 类似Map, 随机位置, 增加并发度
    - 最后 sum(计数字段)
    
### Alter Table
1. 对大表是个大问题
2. mysql执行大部分修改表结构操作的方法
    - 创建一个空表
    - 从旧表中查所有数据插入新表
    - 删除旧表
3. 常见解决方案
    - 在一台不提供服务的实例上执行 Alter Table 操作, 然后切换主库
    - 影子拷贝
        - 用要求的表结构创建一个和源表无关的新表
        - 通过重命名和删表操作交换两张表
4. 不会引起Alter table 操作重建表
    - Alter Table "anmae" Modify Column ...  --> 重建
    - Alter Table "anmae" **Alter Column** ...  --> **直接修改 .frm 文件而不涉及表数据**
    
### 只修改 .frm 文件
1. TODO

### 总结
1. 简单就好了...