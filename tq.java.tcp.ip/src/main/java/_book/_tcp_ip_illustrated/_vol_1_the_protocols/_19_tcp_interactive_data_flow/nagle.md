2018-12-10

## Nagel 算法

### 解决的问题
1. TCP/IP中无论发送多少数据, 都需要在数据前面加上协议头, 同时, 需要数据接收方ACK.
2. 尽可能发送大块数据,避免网络中充斥着许多小数据块
3. 要求: 一个TCP 连接上最多只能有一个未被确认的未完成的小分组
3. 方式
    - 在已发送一个数据包, 但是接受方的 ACK尚未到达
    - 可以将这短时间内待发送的数据包组装到一起

### 要求
1. 任意时刻,最多只能有一个未被确认的小段

### 规则
1. 如果报长度达到 MSS, 发送
2. 该包含有 FIN, 发送
3. 设置 TCP_NODELAY, 发送
4. 未设置TCP_CORK选项时,若所有发出去的小数据包(包长度小于MSS)均被确认,则允许发送；
5. 上述条件都未满足,但发生了超时(一般为200ms),则立即发送.

### 问题
1. 算法完全由TCP协议的ACK机制决定, 
    - 如果对端 ACK 回复很快的话, Nagle不会拼接太多的数据包
    - 网络总体利用率较低
2. 因为需要拼接包然后在发送, 造成TCP封包与拆包
    - 定长
    - 数据长度与数据包
    - 特殊分隔符
    
### TCP_CORK
1. 塞子
2. 内核会尽力把小数据包拼接成一个大的数据包(一个MTU)再发送出去,当然若一定时间后(一般为200ms,该值尚待确认),
    内核仍然没有组合成一个MTU时也必须发送现有的数据
3. 问题
    - 应用层程序发送小包数据的间隔不够短时TCP_CORK就没有一点作用
    - 反而会失去数据的实时性

### Nagle vs Cork
1. 不同
    - Nagle
        - 主要避免网络因为太多的小包(协议头占主要部分)而拥塞
    - Cork
        - 提高网络利用率
2. 相同
    - 都是避免发送小包
