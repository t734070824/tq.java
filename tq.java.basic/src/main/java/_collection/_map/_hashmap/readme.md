2018-04-16

### resize
1. 一个链表有多个元素的是时候, 扩容是如何
    - 反向链表
    - 两个链表
    - 一个在前面, 一个在扩容后的空间里

### HashMap 的 hashcode 设计
1. (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
2. 如果直接使用散列值所谓下标访问 HashMap 注数组的话, 2进制32位带符号的int值范围是-2147483648到2147483648, 有40亿的空间, 
    只要哈希函数映射的比较均匀松散, 一般应用很难碰撞
3. 40亿的数据 内存无法存放
4. HashMap 扩容之前的初始数组的大小为 16, 需要取模, 获取下标
    - **可以自定义初始容量, 但是初始容量会修正为 大于给定值的最小的一个 2次幂数**
5. 为什么 HashMap 的数组长度要取 2 的整数次幂
    - 因为 length - 1 正好相当于一个 **低位掩码**, 
    - 与 操作的结果就是散列值的高位全部归零,只保留低位值
6. **扰动函数**         
    - 因为 length - 1 正好相当于一个 **低位掩码**,  造成高位 在hash运算的 参与度很低
    - 做 高低位异或, 使低位也有高位的特点
    - 无符号右移16位, 自己的高半区 与 低半区 做异或, **混合原始哈希码的高位和低位，以此来加大低位的随机性**   
    
### HashMap.size = 2的n次幂
1. 当容量一定是2^n时，h & (length - 1) == h % length
2. 按位运算特别快
    
### JDK7 VS JDK8 HashMap
1. put:
    - JDK7: 数据找下标, 放在链表头部
    - JDK8: 数据找下标, **列表 转 红黑树**
    

    
    
    