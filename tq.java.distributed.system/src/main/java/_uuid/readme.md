2019-03-13

## 分布式唯一ID

### 核心需求
1. 全局唯一
2. 趋势有序

### 用数据库的 auto_increment 来生成
1. 优点
    - 相对简单, 直接借用数据库原有功能
    - 唯一
    - 递增
    - id之间的步长是固定的且可以自定义
2. 缺点
    - 可用性难以保证: 主库宕机
    - 扩展性差, 数据库主库的写性能决定ID的生成性能上线
4. 改进方案
    - 1
        - 实现
            - 冗余主库, 避免单点故障
            - 数据水平切分, 保证主库生成的ID不重复
            - **写库设置不同的 auto_increment 初始值, 以及相同的增长步长**
                - **步长决定有多少个 节点**
            - 
            ![](1.png)
        - 缺点
            - 不再是 绝对递增, 是 趋势递增
            - 每次任然需要访问数据库

### 单点批量ID生成服务
![](2.png)

1. 优点
    - 使用批量的方式降低数据库写压力
    - 多 master 保证可用性, 数据库中之只储最大值
    - 保证了ID生成的绝对递增有序
    - 大大的降低了数据库的压力
2. 缺点
    - 服务仍然是单点
    - 如果服务宕机, 服务重启起来之后，继续生成ID可能会不连续，中间出现空洞
    - 有性能上限 无法水平扩展
3. 改进方案
    - 单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点：
    -  vip+keepalived 实现故障转移
    - 但会引发 一致性问题

### UUID
1. 优点
    - 本地, 时延低
    - 扩展性好
3. 缺点
    - **无法保证趋势递增**
    - uuid过长, 作为数据库主键索引查询效率低
    - 常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）

### 取当前毫秒数
1. 优点
    - 本地生成ID，不需要进行远程调用，时延低
    - 生成的ID趋势递增
    - 生成的ID是整数，建立索引后查询效率高
2. 缺点
    - 如果并发量超过1000，会生成重复的ID
    
### 使用 Redis 来生成 id
1. 可以用Redis的原子操作 INCR 和 INCRBY 来实现。
1. 优点
    - 依赖于数据库，灵活方便，且性能优于数据库。
    - 数字ID天然排序，对分页或者需要排序的结果很有帮助。
2. 缺点
    - 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
    - 需要编码和配置的工作量比较大。

### Twitter 开源的 Snowflake 算法
1. snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID：
    - 41 bit 作为毫秒数 - 41位的长度可以使用69年
    - 10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点
    - 12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号
    - 算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。
    - 
    ![](3.png)

    
